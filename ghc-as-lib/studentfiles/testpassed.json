[
    {
        "exerciseid": "haskell/encoding/fromBin",
        "input": "fromBin [] = 0\nfromBin xs = (last xs) + 2 * fromBin (init xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "fromBin [] =\n    0\nfromBin xs =\n    (last xs) + 2 * fromBin (init xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "fromBin :: [Int] -> Int"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat xs y = head (drop (y - 1) xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat xs y =\n    head (drop (y - 1) xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength = length",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "mylength =\n    length",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast [] =  _\nmylast x = head (reverse x)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "mylast [] =\n    ?\nmylast x =\n    head (reverse x)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat a n = head (drop (n-1) a)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat a n =\n    head (drop (n - 1) a)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast [] =  _\nmylast (x : []) = x\nmylast (x : xs) = mylast xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "mylast [] =\n    ?\nmylast (x : []) =\n    x\nmylast (x : xs) =\n    mylast xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength a = length a",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "mylength a =\n    length a",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) 1 = x\nelementat [x] n = x\nelementat (x:xs) n = elementat (xs) (n - 1)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat (x : xs) 1 =\n    x\nelementat [x] n =\n    x\nelementat (x : xs) n =\n    elementat (xs) (n - 1)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength []  = 0\nmylength (x : []) = 1\nmylength (x : xs) = 1 + mylength xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "mylength [] =\n    0\nmylength (x : []) =\n    1\nmylength (x : xs) =\n    1 + mylength xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome [] = True\npalindrome (x:xs) = if reverse (x:xs) == (x:xs) then True else False",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "palindrome [] =\n    True\npalindrome (x : xs) =\n    if reverse (x : xs) == (x : xs)\n        then True\n        else False",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome [] = True\npalindrome xs = if zs == xs then True else False\n   where zs = reverse xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "palindrome [] =\n    True\npalindrome xs =\n    if zs == xs\n        then True\n        else False\n    where\n        zs =\n            reverse xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [[]] = []\nmyconcat xs = foldr (++) [] xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myconcat [[]] =\n    []\nmyconcat xs =\n    foldr (++) [] xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress (x:y:ys) | x == y = x : compress ys\n                  | x /= y = x : y : compress ys\ncompress (x:xs) = x : xs\ncompress [] = []",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "compress (x : y : ys) \n    | x == y = x : compress ys\n    | x /= y = x : y : compress ys\ncompress (x : xs) =\n    x : xs\ncompress [] =\n    []",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat a b = head (reverse (take b a))",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat a b =\n    head (reverse (take b a))",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse [] = []\nmyreverse (x : []) = [x]\nmyreverse (x : xs) = myreverse xs ++ [x]",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myreverse [] =\n    []\nmyreverse (x : []) =\n    [x]\nmyreverse (x : xs) =\n    myreverse xs ++ [x]",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) n |n==1 = x\n                   |otherwise = elementat xs (n-1)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat (x : xs) n \n    | n == 1 = x\n    | otherwise = elementat xs (n - 1)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse []     = []\nmyreverse (x:xs) = (myreverse xs) ++ (x:[])",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myreverse [] =\n    []\nmyreverse (x : xs) =\n    (myreverse xs) ++ (x : [])",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = [] \ncompress [x] = [x]\ncompress (x:y:xs) | x == y = compress(x:xs)\n                  | otherwise = (x:y: compress xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "compress [] =\n    []\ncompress [x] =\n    [x]\ncompress (x : y : xs) \n    | x == y = compress (x : xs)\n    | otherwise = (x : y : compress xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse xs = reverse xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myreverse xs =\n    reverse xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = []\ncompress (x:[]) = [x]\ncompress (x:xs) |x == head xs = compress xs\n                |otherwise = x : compress xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "compress [] =\n    []\ncompress (x : []) =\n    [x]\ncompress (x : xs) \n    | x == head xs = compress xs\n    | otherwise = x : compress xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse (x:xs) = end (x:xs) : myreverse (front (x:xs))\n                     where end [x] = x\n                           end (x:xs) = end xs \n                           front [x] = []\n                           front [x,y] = [x]\n                           front (x:xs) = x : front xs\nmyreverse [] = []",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myreverse (x : xs) =\n    end (x : xs) : myreverse (front (x : xs))\n    where\n        end [x] =\n            x\n        end (x : xs) =\n            end xs\n        front [x] =\n            []\n        front [x,y] =\n            [x]\n        front (x : xs) =\n            x : front xs\nmyreverse [] =\n    []",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat a 1 = head a\nelementat (x:xs) i = elementat xs (i-1)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "elementat a 1 =\n    head a\nelementat (x : xs) i =\n    elementat xs (i - 1)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome [] = True\npalindrome lijst | even (length lijst) = take mid lijst == \n                                         reverse (drop (mid) lijst)\n                 | otherwise = take mid lijst == \n                               reverse (drop (mid+1) lijst)\n                 where mid = (length lijst) `div` 2",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "palindrome [] =\n    True\npalindrome lijst \n    | even (length lijst) = take mid lijst == reverse (drop (mid) lijst)\n    | otherwise = take mid lijst == reverse (drop (mid + 1) lijst)\n    where\n        mid =\n            (length lijst) `div` 2",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = []\npack (x:xs) = (takeWhile (== x) (x:xs)) : pack (dropWhile (== x) xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "pack [] =\n    []\npack (x : xs) =\n    (takeWhile (== x) (x : xs)) : pack (dropWhile (== x) xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome [] = True\npalindrome [x] = True\npalindrome [x,y] | x==y = True\n                 | otherwise = False\npalindrome (x:xs) | x == end xs = palindrome (front xs)\n                  | otherwise = False\n                     where end [x] = x\n                           end (x:xs) = end xs\n                           front [x] = []\n                           front [x,y] = [x]\n                           front (x:xs) = x : front xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "palindrome [] =\n    True\npalindrome [x] =\n    True\npalindrome [x,y] \n    | x == y = True\n    | otherwise = False\npalindrome (x : xs) \n    | x == end xs = palindrome (front xs)\n    | otherwise = False\n    where\n        end [x] =\n            x\n        end (x : xs) =\n            end xs\n        front [x] =\n            []\n        front [x,y] =\n            [x]\n        front (x : xs) =\n            x : front xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat (x:xs) = x ++ concat xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myconcat [] =\n    []\nmyconcat (x : xs) =\n    x ++ concat xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome [] = True\npalindrome [x] = True\npalindrome (x:xs) | x == end xs = palindrome (front xs)\n                  | otherwise = False\n                     where end [x] = x\n                           end (x:xs) = end xs\n                           front [x] = []\n                           front [x,y] = [x]\n                           front (x:xs) = x : front xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "palindrome [] =\n    True\npalindrome [x] =\n    True\npalindrome (x : xs) \n    | x == end xs = palindrome (front xs)\n    | otherwise = False\n    where\n        end [x] =\n            x\n        end (x : xs) =\n            end xs\n        front [x] =\n            []\n        front [x,y] =\n            [x]\n        front (x : xs) =\n            x : front xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = [[]]\npack (x:xs) = f (pack xs) \n   where\n     f [] = [[x]]\n     f([]:ls) = [x]:ls\n     f((y:ys):ls) = if x == y then ((x:y:ys):ls)\n                     else (x:[]):(y:ys):ls",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "pack [] =\n    [[]]\npack (x : xs) =\n    f (pack xs)\n    where\n        f [] =\n            [[x]]\n        f ([] : ls) =\n            [x] : ls\n        f ((y : ys) : ls) =\n            if x == y\n                then ((x : y : ys) : ls)\n                else (x : []) : (y : ys) : ls",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = []\npack (x:xs) = f r\n              where r = pack xs\n                    f [] = [[x]]\n                    f ([]:ls) = [x] : ls\n                    f ((y:ys):ls) = if x == y then ((x:y:ys):ls) else (x:[]):(y:ys):ls",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "pack [] =\n    []\npack (x : xs) =\n    f r\n    where\n        r =\n            pack xs\n        f [] =\n            [[x]]\n        f ([] : ls) =\n            [x] : ls\n        f ((y : ys) : ls) =\n            if x == y\n                then ((x : y : ys) : ls)\n                else (x : []) : (y : ys) : ls",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress []     = []\ncompress (x:xs) = x: (compress (filter (/=x) xs))",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "compress [] =\n    []\ncompress (x : xs) =\n    x : (compress (filter (/= x) xs))",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/encode",
        "input": "encode [] = []\nencode (x:[]) = [(1,x)]\nencode (x:xs) = (length (takeWhile (==x) (x:xs)), x) : encode (dropWhile (==x) xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "encode [] =\n    []\nencode (x : []) =\n    [(1,x)]\nencode (x : xs) =\n    (length (takeWhile (== x) (x : xs))\n    ,x) : encode (dropWhile (== x) xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "encode :: Eq a => [a] -> [(Int, a)]"
    },
    {
        "exerciseid": "haskell/list/encode",
        "input": "encode [] = []\nencode (x:xs) = (length (takeWhile (==x) (x:xs)), x) : encode (dropWhile (==x) xs)",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "encode [] =\n    []\nencode (x : xs) =\n    (length (takeWhile (== x) (x : xs))\n    ,x) : encode (dropWhile (== x) xs)",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "encode :: Eq a => [a] -> [(Int, a)]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat [x] = x\nmyconcat (x:xs) = x ++ myconcat xs",
        "output": {
            "result": [
                false,
                "Your solution passed all tests! However, it is different from the solutions we have constructed.",
                "myconcat [] =\n    []\nmyconcat [x] =\n    x\nmyconcat (x : xs) =\n    x ++ myconcat xs",
                false
            ],
            "error": null
        },
        "category": "TestPassed",
        "typesig": "myconcat :: [[a]] -> [a]"
    }
]