[
 {
  "id": 2677,
  "email": "noakpa@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin bits = sum $ zipWith (\\a b -> a * 2^b) bits (reverse [0 .. length bits - 1])\n",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin bits = sum $ zipWith (\\a b -> a * 2^b) bits (reverse [0 .. length bits - 1])\n",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 2660,
  "email": "arvidboi@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome list = palindrome' list (reverse list)\n\npalindrome' [] [] = True\npalindrome' (x:list) (y:revlist) | x == y = palindrome' list revlist\n  | otherwise = False",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome list = palindrome' list (reverse list)\n\npalindrome' [] [] = True\npalindrome' (x:list) (y:revlist) | x == y = palindrome' list revlist\n  | otherwise = False",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 2682,
  "email": "noakpa@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin bits = sum $ zipWith (\\a b -> a * 2^b) bits (reverse [0 .. length bits - 1])\n",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin bits = sum $ zipWith (\\a b -> a * 2^b) bits (reverse [0 .. length bits - 1])\n",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 3093,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "dupli = concat . map (\\x -> [x,x]) ",
  "typesig": "",
  "input": "dupli = concat . map (\\x -> [x,x]) ",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3180,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = foldr (\\a acc -> [a,a] ++ acc ) []",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli = foldr (\\a acc -> [a,a] ++ acc ) []",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3232,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap (\\x -> [x,x]) ",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap (\\x -> [x,x]) ",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3486,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin = sum . foldl (\\acc b -> if b == 1 then b : (map ((*) 2) acc) else (map ((*)2) acc) ) []",
  "typesig": "",
  "input": "fromBin = sum . foldl (\\acc b -> if b == 1 then b : (map ((*) 2) acc) else (map ((*)2) acc) ) []",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 3536,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin = foldl (\\acc b -> acc * 2 + b) 0",
  "typesig": "",
  "input": "fromBin = foldl (\\acc b -> acc * 2 + b) 0",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 4523,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "primes = filter isPrime [2..]\n\nisPrime p = not $ any (\\q -> p `mod` q == 0) [2..p - 1]",
  "typesig": "",
  "input": "primes = filter isPrime [2..]\n\nisPrime p = not $ any (\\q -> p `mod` q == 0) [2..p - 1]",
  "category": "TestPassed",
  "exerciseid": "haskell/list/primes"
 },
 {
  "id": 4524,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin = sum . map (\\a -> 2 ^ fst a * snd a). zip [0..] . reverse",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin = sum . map (\\a -> 2 ^ fst a * snd a). zip [0..] . reverse",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 4680,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "mylength = length",
  "typesig": "",
  "input": "mylength = length",
  "category": "TestPassed",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 5366,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\nencode = map (\\l -> (length l, head l)). group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "typesig": "",
  "input": "\nencode = map (\\l -> (length l, head l)). group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/encode"
 },
 {
  "id": 5082,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\ncompress = map (head) . group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "typesig": "",
  "input": "\ncompress = map (head) . group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 5083,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\ncompress = map (head) . group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "typesig": "",
  "input": "\ncompress = map (head) . group\n  where\n    group []           =  []\n    group (x:xs)       =  (x:ys) : group zs\n                           where (ys,zs) = span (== x) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 5429,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "compress :: [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) = if x /= y then x : c else c\n  where c = compress $ y:xs",
  "typesig": "",
  "input": "compress :: [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) = if x /= y then x : c else c\n  where c = compress $ y:xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 24353,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin []  = 0\nfromBin [x] = x\nfromBin (x:xs) = x * 2 ^ (length xs) + fromBin xs",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin []  = 0\nfromBin [x] = x\nfromBin (x:xs) = x * 2 ^ (length xs) + fromBin xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 6279,
  "email": "wesoghdruiofghuo@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "--import Network.Socket hiding (send, sendTo, recv, recvFrom)\n\nfromBin [] = 0\nfromBin (x:xs) = x * 2^(length xs) + fromBin xs",
  "typesig": "",
  "input": "--import Network.Socket hiding (send, sendTo, recv, recvFrom)\n\nfromBin [] = 0\nfromBin (x:xs) = x * 2^(length xs) + fromBin xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 7032,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\n\nfromBin :: [Int] -> Int\nfromBin xs = fromBin' xs (length xs - 1)\n\nfromBin' :: [Int] -> Int -> Int\nfromBin' [] _ = 0\nfromBin' (x:xs) n = case x of\n    0 -> fromBin' xs (n-1)\n    1 -> product (replicate n 2) + fromBin' xs (n-1)",
  "typesig": "",
  "input": "\n\nfromBin :: [Int] -> Int\nfromBin xs = fromBin' xs (length xs - 1)\n\nfromBin' :: [Int] -> Int -> Int\nfromBin' [] _ = 0\nfromBin' (x:xs) n = case x of\n    0 -> fromBin' xs (n-1)\n    1 -> product (replicate n 2) + fromBin' xs (n-1)",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 7583,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\nencode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\nencode (x:xs) = (1 + length xs', x) : encode ys\n    where\n        xs' = takeWhile (== x) xs\n        ys  = dropWhile (== x) xs",
  "typesig": "",
  "input": "\nencode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\nencode (x:xs) = (1 + length xs', x) : encode ys\n    where\n        xs' = takeWhile (== x) xs\n        ys  = dropWhile (== x) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/encode"
 },
 {
  "id": 7660,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\n\nmylength :: [a] -> Int\nmylength = foldr (\\x z -> z + 1) 0",
  "typesig": "",
  "input": "\n\nmylength :: [a] -> Int\nmylength = foldr (\\x z -> z + 1) 0",
  "category": "TestPassed",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 7880,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\n\npalindrome :: Eq a => [a] -> Bool\npalindrome xs = and (map (\\(a, b) -> a == b) (zip xs (reverse xs)))",
  "typesig": "",
  "input": "\n\npalindrome :: Eq a => [a] -> Bool\npalindrome xs = and (map (\\(a, b) -> a == b) (zip xs (reverse xs)))",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 8857,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [x] = 1\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [x] = 1\nmylength (x:xs) = 1 + mylength xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 9171,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse [x] = [x]\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse [x] = [x]\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 9504,
  "email": "melvinla@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin []     = 0\nfromBin (0:xs) = fromBin xs\nfromBin (1:xs) = 2^(length xs) + fromBin xs",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin []     = 0\nfromBin (0:xs) = fromBin xs\nfromBin (1:xs) = 2^(length xs) + fromBin xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 9939,
  "email": "melvinla@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "encode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\nencode (x:xs) = (l, x) : encode rest\n  where\n    l = length (takeWhile (==x) (x:xs))\n    rest = dropWhile (==x) xs",
  "typesig": "",
  "input": "encode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\nencode (x:xs) = (l, x) : encode rest\n  where\n    l = length (takeWhile (==x) (x:xs))\n    rest = dropWhile (==x) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/encode"
 },
 {
  "id": 10079,
  "email": "olleande@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin bits =  foldl (\\acc bit -> 2*acc + bit) 0 bits",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin bits =  foldl (\\acc bit -> 2*acc + bit) 0 bits",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 25550,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = reverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = reverse xs ++ [x]",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 25673,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse xs = foldl (\\x y -> y:x) [] xs\n  ",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse xs = foldl (\\x y -> y:x) [] xs\n  ",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 10845,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "\n\nprimes :: [Int]\nprimes = filter isPrime (2:[3,5..])\n\nisPrime :: Int -> Bool\nisPrime x = foldr (\\y z -> (mod x y /= 0) && z) True (takeWhile (< x) (2:[3,5..]))\n",
  "typesig": "",
  "input": "\n\nprimes :: [Int]\nprimes = filter isPrime (2:[3,5..])\n\nisPrime :: Int -> Bool\nisPrime x = foldr (\\y z -> (mod x y /= 0) && z) True (takeWhile (< x) (2:[3,5..]))\n",
  "category": "TestPassed",
  "exerciseid": "haskell/list/primes"
 },
 {
  "id": 11444,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) (reverse xs) (map (\\x -> 2^x) [0..length xs])",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) (reverse xs) (map (\\x -> 2^x) [0..length xs])",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 11679,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs (map (\\x -> 2^x) $ reverse l)\n  where l = [0..length xs - 1]\n  ",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs (map (\\x -> 2^x) $ reverse l)\n  where l = [0..length xs - 1]\n  ",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 11687,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs (map (2^) $ reverse l)\n  where l = [0..length xs - 1]\n  ",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs (map (2^) $ reverse l)\n  where l = [0..length xs - 1]\n  ",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 11692,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs $ map (2^) $ reverse l\n  where l = [0..length xs - 1]\n  ",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) xs $ map (2^) $ reverse l\n  where l = [0..length xs - 1]\n  ",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 11880,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = foldl (\\x y -> x*2 + y) 0 xs",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = foldl (\\x y -> x*2 + y) 0 xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 12294,
  "email": "sevelin@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress []  = []\ncompress [x] = [x]\ncompress (x:y:ys)\n  | x == y = x : compress ys\n  | otherwise = x : compress (y:ys)\n",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress []  = []\ncompress [x] = [x]\ncompress (x:y:ys)\n  | x == y = x : compress ys\n  | otherwise = x : compress (y:ys)\n",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 14221,
  "email": "ellalind@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin x  = fromBin' (reverse x) 1\n\nfromBin' :: [Int] -> Int -> Int\nfromBin' [x] i    = x * i\nfromBin' (x:xs) i = (x * i) + fromBin' xs (i * 2)",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin x  = fromBin' (reverse x) 1\n\nfromBin' :: [Int] -> Int -> Int\nfromBin' [x] i    = x * i\nfromBin' (x:xs) i = (x * i) + fromBin' xs (i * 2)",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 14297,
  "email": "gusnorbead@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [x] = 1\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [x] = 1\nmylength (x:xs) = 1 + mylength xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 15690,
  "email": "maciejg@student.chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin [x] = x\nfromBin xs = 2*(fromBin (init xs)) + last xs",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin [x] = x\nfromBin xs = 2*(fromBin (init xs)) + last xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 16309,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [a] = [a]\ncompress (x:xs) | x == head xs = compress xs | otherwise = x : compress xs ",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [a] = [a]\ncompress (x:xs) | x == head xs = compress xs | otherwise = x : compress xs ",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 16430,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli [a] = [a,a]\ndupli (x:xs) = x:x: dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli [a] = [a,a]\ndupli (x:xs) = x:x: dupli xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 16438,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli [a] = [a,a]\ndupli (x:xs) = x: x: dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli [a] = [a,a]\ndupli (x:xs) = x: x: dupli xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 16538,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [a] = 1\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength [a] = 1\nmylength (x:xs) = 1 + mylength xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 16653,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse [a] = [a]\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse [a] = [a]\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 16816,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 16836,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs && True",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs && True",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 17010,
  "email": "gusreipe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs && palindrome (tail (reverse xs))",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome [a] = True\npalindrome (x:xs) = x == last xs && palindrome (tail (reverse xs))",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 18055,
  "email": "gusmuusta@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse' ys []     = ys\nmyreverse' ys (x:xs) = myreverse' (x:ys) xs\nmyreverse = myreverse' []",
  "typesig": "",
  "input": "myreverse' ys []     = ys\nmyreverse' ys (x:xs) = myreverse' (x:ys) xs\nmyreverse = myreverse' []",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 18060,
  "email": "gusmuusta@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "myreverse = myreverse' []\nmyreverse' ys []     = ys\nmyreverse' ys (x:xs) = myreverse' (x:ys) xs",
  "typesig": "",
  "input": "myreverse = myreverse' []\nmyreverse' ys []     = ys\nmyreverse' ys (x:xs) = myreverse' (x:ys) xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 21056,
  "email": "gushogjod@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) (iterate (*2) 1) (reverse xs)\n",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = sum $ zipWith (*) (iterate (*2) 1) (reverse xs)\n",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 18937,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin (x:xs) = x*2^(length xs) + fromBin xs",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin [] = 0\nfromBin (x:xs) = x*2^(length xs) + fromBin xs",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 19679,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress (x:y:ys)\n    | x == y = compress (y:ys)\n    | otherwise = x : compress (y:ys)\ncompress ys = ys",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress (x:y:ys)\n    | x == y = compress (y:ys)\n    | otherwise = x : compress (y:ys)\ncompress ys = ys",
  "category": "TestPassed",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 26622,
  "email": "gusmostad@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "dupli :: [a] -> [a]\ndupli []     = []\ndupli [a]    = [a,a]\ndupli (x:xs) = [x,x] ++ dupli xs ",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli []     = []\ndupli [a]    = [a,a]\ndupli (x:xs) = [x,x] ++ dupli xs ",
  "category": "TestPassed",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 19946,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome xs\n    | head xs == last xs = True && palindrome (drop 1 (take (length xs - 1) xs))\n    | otherwise = False",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome [] = True\npalindrome xs\n    | head xs == last xs = True && palindrome (drop 1 (take (length xs - 1) xs))\n    | otherwise = False",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 20237,
  "email": "galldin@chalmers.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin bits = foldl (\\acc bit -> acc * 2 + bit) 0 bits",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin bits = foldl (\\acc bit -> acc * 2 + bit) 0 bits",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 21265,
  "email": "gushogjod@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin = foldl (\\x y -> 2*x + y) 0",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin = foldl (\\x y -> 2*x + y) 0",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 21375,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome xs = reverse xs == xs",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome xs = reverse xs == xs",
  "category": "TestPassed",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 21966,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": false,
  "feedback": "Your solution passed all tests! However, it is different from the solutions we have constructed.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = calcHelper xs (length xs - 1)\n\ncalcHelper :: [Int] -> Int -> Int\ncalcHelper [] _ = 0\ncalcHelper [x] _ = x\ncalcHelper (x:xs) n | x == 1 = 2^n + calcHelper xs (n-1)\n                    | otherwise = calcHelper xs (n-1)",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs = calcHelper xs (length xs - 1)\n\ncalcHelper :: [Int] -> Int -> Int\ncalcHelper [] _ = 0\ncalcHelper [x] _ = x\ncalcHelper (x:xs) n | x == 1 = 2^n + calcHelper xs (n-1)\n                    | otherwise = calcHelper xs (n-1)",
  "category": "TestPassed",
  "exerciseid": "haskell/encoding/fromBin"
 }
]