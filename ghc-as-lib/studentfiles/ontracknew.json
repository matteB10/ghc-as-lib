[
 {
  "id": 2828,
  "email": "noakpa@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "dupli = foldl ? ?",
  "typesig": "",
  "input": "dupli = foldl  _  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 2786,
  "email": "noakpa@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "dupli = ?",
  "typesig": "",
  "input": "dupli =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 2870,
  "email": "noakpa@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "dupli = foldl (\\x acc -> ?) ?",
  "typesig": "",
  "input": "dupli = foldl (\\x acc ->  _)  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3651,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "You have submitted a similar term. Maybe you inserted or removed parentheses?",
  "code": "",
  "typesig": "",
  "input": "",
  "category": "OnTrack",
  "exerciseid": "haskell/list/"
 },
 {
  "id": 3215,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = ?",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3236,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap ?",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3491,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin = ?",
  "typesig": "",
  "input": "fromBin =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 3554,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin = foldl ? ?",
  "typesig": "",
  "input": "fromBin = foldl  _  _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 3642,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin = \n  foldl ? 0",
  "typesig": "",
  "input": "fromBin = \n  foldl  _ 0",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 3646,
  "email": "paulso@net.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin =\n   foldl ? 0\n   where\n       op ? ? =\n           ?",
  "typesig": "",
  "input": "fromBin =\n   foldl  _ 0\n   where\n       op  _  _ =\n            _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 24964,
  "email": "a@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "encode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\n?",
  "typesig": "",
  "input": "encode :: Eq a => [a] -> [(Int, a)]\nencode [] = []\n _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/encode"
 },
 {
  "id": 11827,
  "email": "sevelin@student.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin :: [Int] -> Int\nfromBin xs = ?",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin xs =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 12037,
  "email": "sevelin@student.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress xs = ?\n",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress xs =  _\n",
  "category": "OnTrack",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 13179,
  "email": "gusvuongma@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0",
  "category": "OnTrack",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 25958,
  "email": "johan@gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin xs = ?",
  "typesig": "",
  "input": "fromBin xs =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 15247,
  "email": "ellalind@student.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse (x:xs) = (myreverse xs) ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse (x:xs) = (myreverse xs) ++ [x]",
  "category": "OnTrack",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 15859,
  "email": "maciejg@student.chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "myreverse [] = []\nmyreverse (x:xs) = ?",
  "typesig": "",
  "input": "myreverse [] = []\nmyreverse (x:xs) =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 17838,
  "email": "gusmuusta@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = ?",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 21075,
  "email": "gushogjod@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin :: [Int] -> Int\nfromBin = ?\n",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin =  _\n",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 19117,
  "email": "gusvuongma@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a] \ndupli [] = []\n",
  "typesig": "",
  "input": "dupli :: [a] -> [a] \ndupli [] = []\n",
  "category": "OnTrack",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 19520,
  "email": "leesment@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress (x:y:ys)\n    | x == y = compress (y:ys)\n    | otherwise = x : compress (y:ys)",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress (x:y:ys)\n    | x == y = compress (y:ys)\n    | otherwise = x : compress (y:ys)",
  "category": "OnTrack",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 20465,
  "email": "leesment@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "repli :: [a] -> Int -> [a]\nrepli = ?",
  "typesig": "",
  "input": "repli :: [a] -> Int -> [a]\nrepli =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 20497,
  "email": "leesment@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "primes :: [Int]\nprimes = ?",
  "typesig": "",
  "input": "primes :: [Int]\nprimes =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/primes"
 },
 {
  "id": 20527,
  "email": "leesment@chalmers.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength = ?",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength =  _",
  "category": "OnTrack",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 21144,
  "email": "gushogjod@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin :: [Int] -> Int\nfromBin = ? . ?",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin =  _ .  _",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 },
 {
  "id": 21166,
  "email": "gushogjod@student.gu.se",
  "solved": false,
  "solved_model": false,
  "feedback": "Correct.",
  "code": "fromBin :: [Int] -> Int\nfromBin = foldl ? ?\n",
  "typesig": "",
  "input": "fromBin :: [Int] -> Int\nfromBin = foldl  _  _\n",
  "category": "OnTrack",
  "exerciseid": "haskell/encoding/fromBin"
 }
]