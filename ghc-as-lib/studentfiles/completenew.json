[
 {
  "id": 3047,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse [] = []\nmyreverse (x : xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse [] = []\nmyreverse (x : xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 3210,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = foldl (\\acc a -> acc ++ [a,a] ) []",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli = foldl (\\acc a -> acc ++ [a,a] ) []",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3269,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap (replicate 2)",
  "typesig": "",
  "input": "--dupli = concat . map (\\x -> [x,x]) \ndupli = concatMap (replicate 2)",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3321,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "\npalindrome a = a == reverse a",
  "typesig": "",
  "input": "\npalindrome a = a == reverse a",
  "category": "Complete",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 5198,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 3913,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "repli :: [a] -> Int -> [a]\nrepli l n = concatMap (replicate n) l",
  "typesig": "",
  "input": "repli :: [a] -> Int -> [a]\nrepli l n = concatMap (replicate n) l",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 4023,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "palindrome :: Eq a => [a] -> Bool\npalindrome l = l == reverse l",
  "typesig": "",
  "input": "palindrome :: Eq a => [a] -> Bool\npalindrome l = l == reverse l",
  "category": "Complete",
  "exerciseid": "haskell/list/palindrome"
 },
 {
  "id": 4109,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 4205,
  "email": "oskartor@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 4636,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "repli xs i = concatMap (replicate i) xs",
  "typesig": "",
  "input": "repli xs i = concatMap (replicate i) xs",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 4736,
  "email": "paulso@net.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength [] = 0\nmylength (x : xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength [] = 0\nmylength (x : xs) = 1 + mylength xs",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 24721,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n  | x == y    = compress(y:xs)\n  | otherwise = x : compress(y:xs) ",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n  | x == y    = compress(y:xs)\n  | otherwise = x : compress(y:xs) ",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 7279,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "\n\ncompress :: Eq a => [a] -> [a]\ncompress []  = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "typesig": "",
  "input": "\n\ncompress :: Eq a => [a] -> [a]\ncompress []  = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 7363,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "\n\ndupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "\n\ndupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 24893,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 7758,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "\n\nmyreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "\n\nmyreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 9712,
  "email": "melvinla@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) =\n      if x == y then\n        compress (y:xs)\n      else\n        x : compress (y:xs)",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) =\n      if x == y then\n        compress (y:xs)\n      else\n        x : compress (y:xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 8075,
  "email": "gusporssi@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "\n\nrepli :: [a] -> Int -> [a]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "typesig": "",
  "input": "\n\nrepli :: [a] -> Int -> [a]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 9773,
  "email": "melvinla@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 9060,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "repli :: [a] -> Int -> [a]\nrepli xs i = concatMap(replicate i) xs",
  "typesig": "",
  "input": "repli :: [a] -> Int -> [a]\nrepli xs i = concatMap(replicate i) xs",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 25445,
  "email": "a@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength []     = 0\nmylength (x:xs) = 1 + mylength xs ",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength []     = 0\nmylength (x:xs) = 1 + mylength xs ",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 10888,
  "email": "gusalchmo@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 10905,
  "email": "gusalchmo@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 10920,
  "email": "gusalchmo@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "repli :: [a] -> Int -> [a]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "typesig": "",
  "input": "repli :: [a] -> Int -> [a]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 },
 {
  "id": 10930,
  "email": "gusalchmo@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 10936,
  "email": "gusalchmo@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs)\n    | x == y    = compress (y:xs)\n    | otherwise = x : compress (y:xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 11119,
  "email": "hugohj@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse([]) = []\nmyreverse(x:xs) = myreverse(xs) ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse([]) = []\nmyreverse(x:xs) = myreverse(xs) ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 13791,
  "email": "rezvan@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 15806,
  "email": "maciejg@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 15910,
  "email": "maciejg@student.chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse [] = []\nmyreverse (x:xs) = (myreverse xs) ++ [x]",
  "typesig": "",
  "input": "myreverse [] = []\nmyreverse (x:xs) = (myreverse xs) ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 17883,
  "email": "gusmuusta@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 18817,
  "email": "gusvuongma@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength(xs)\n",
  "typesig": "",
  "input": "mylength :: [a] -> int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength(xs)\n",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 19161,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 20743,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "typesig": "",
  "input": "mylength :: [a] -> Int\nmylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
  "category": "Complete",
  "exerciseid": "haskell/list/mylength"
 },
 {
  "id": 20005,
  "email": "leesment@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x:x:(dupli xs)",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x:x:(dupli xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 20291,
  "email": "galldin@chalmers.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "typesig": "",
  "input": "myreverse :: [a] -> [a]\nmyreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
  "category": "Complete",
  "exerciseid": "haskell/list/myreverse"
 },
 {
  "id": 21552,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) | x == y = compress (x:xs)\n                  | otherwise = x : compress (y:xs)",
  "typesig": "",
  "input": "compress :: Eq a => [a] -> [a]\ncompress [] = []\ncompress [x] = [x]\ncompress (x:y:xs) | x == y = compress (x:xs)\n                  | otherwise = x : compress (y:xs)",
  "category": "Complete",
  "exerciseid": "haskell/list/compress"
 },
 {
  "id": 21627,
  "email": "gusgabrbe@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "typesig": "",
  "input": "dupli :: [a] -> [a]\ndupli [] = []\ndupli (x:xs) = x : x : dupli xs",
  "category": "Complete",
  "exerciseid": "haskell/list/dupli"
 },
 {
  "id": 22725,
  "email": "gusmostad@student.gu.se",
  "solved": true,
  "solved_model": true,
  "feedback": "Correct.",
  "code": "repli :: [int] -> Int -> [int]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "typesig": "",
  "input": "repli :: [int] -> Int -> [int]\nrepli [] _ = []\nrepli (x:xs) n = replicate n x ++ repli xs n",
  "category": "Complete",
  "exerciseid": "haskell/list/repli"
 }
]