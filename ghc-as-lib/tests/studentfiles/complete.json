[
    {
        "exerciseid": "haskell/list/dupli",
        "input": "dupli = concatMap (replicate 2)",
        "output": {
            "result": [
                true,
                "Correct.",
                "dupli =\n    concatMap (replicate 2)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "dupli :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast [x] = x\nmylast (x:xs) = mylast xs",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylast [x] =\n    x\nmylast (x : xs) =\n    mylast xs",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast lst = lst !! (length lst - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylast lst =\n    lst !! (length lst - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast = foldr1 (const id)",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylast =\n    foldr1 (const id)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast = head . reverse",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylast =\n    head . reverse",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat lst n = lst !! (n-1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat lst n =\n    lst !! (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) 1 = x\nelementat (x:xs) n = elementat xs (n - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat (x : xs) 1 =\n    x\nelementat (x : xs) n =\n    elementat xs (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat lijst n = lijst !! (n-1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat lijst n =\n    lijst !! (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "\nmylast [x] = x\nmylast (x:xs) = mylast(xs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylast [x] =\n    x\nmylast (x : xs) =\n    mylast (xs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat l n = l !! (n-1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat l n =\n    l !! (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength [] = 0\nmylength (x:xs) = 1 + mylength xs",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength [] =\n    0\nmylength (x : xs) =\n    1 + mylength xs",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat x n = x !! (n - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat x n =\n    x !! (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat a n = a !! (n - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat a n =\n    a !! (n - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength [] = 0\nmylength (x:xs)  = 1 + (mylength xs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength [] =\n    0\nmylength (x : xs) =\n    1 + (mylength xs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse [] = []\nmyreverse (x:xs) = myreverse xs ++ [x]",
        "output": {
            "result": [
                true,
                "Correct.",
                "myreverse [] =\n    []\nmyreverse (x : xs) =\n    myreverse xs ++ [x]",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome x = x == reverse x",
        "output": {
            "result": [
                true,
                "Correct.",
                "palindrome x =\n    x == reverse x",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength [] = 0\nmylength (x:xs) = 1 + mylength (xs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength [] =\n    0\nmylength (x : xs) =\n    1 + mylength (xs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat (xs:xss) = xs ++ myconcat xss",
        "output": {
            "result": [
                true,
                "Correct.",
                "myconcat [] =\n    []\nmyconcat (xs : xss) =\n    xs ++ myconcat xss",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome a = a == reverse a",
        "output": {
            "result": [
                true,
                "Correct.",
                "palindrome a =\n    a == reverse a",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength = \n   foldr ((+) . (const 1)) 0",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength =\n    foldr ((+) . (const 1)) 0",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "\nmyreverse [] = []\nmyreverse (x:xs) = (myreverse(xs)) ++ [x]",
        "output": {
            "result": [
                true,
                "Correct.",
                "myreverse [] =\n    []\nmyreverse (x : xs) =\n    (myreverse (xs)) ++ [x]",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome xs  = xs == (reverse xs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "palindrome xs =\n    xs == (reverse xs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat xs i = \n   xs !! (i - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat xs i =\n    xs !! (i - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse [] = []\nmyreverse (x:xs) = (myreverse xs) ++ [x]",
        "output": {
            "result": [
                true,
                "Correct.",
                "myreverse [] =\n    []\nmyreverse (x : xs) =\n    (myreverse xs) ++ [x]",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat xs = foldr (++) [] xs",
        "output": {
            "result": [
                true,
                "Correct.",
                "myconcat xs =\n    foldr (++) [] xs",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat = foldr (++) []",
        "output": {
            "result": [
                true,
                "You have submitted a similar term. Maybe you inserted or removed parentheses?",
                "myconcat =\n    foldr (++) []",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat (xx:xxs) = xx ++ myconcat( xxs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "myconcat [] =\n    []\nmyconcat (xx : xxs) =\n    xx ++ myconcat (xxs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat (x:xs) = x ++ myconcat xs",
        "output": {
            "result": [
                true,
                "Correct.",
                "myconcat [] =\n    []\nmyconcat (x : xs) =\n    x ++ myconcat xs",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/palindrome",
        "input": "palindrome xs = \n   xs == reverse xs",
        "output": {
            "result": [
                true,
                "Correct.",
                "palindrome xs =\n    xs == reverse xs",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "palindrome :: Eq a => [a] -> Bool"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat list i = list !! (i - 1)",
        "output": {
            "result": [
                true,
                "Correct.",
                "elementat list i =\n    list !! (i - 1)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength (x:xs) = 1 + mylength xs\nmylength [] = 0",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength (x : xs) =\n    1 + mylength xs\nmylength [] =\n    0",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse = \n   (foldl (flip (:)) [])",
        "output": {
            "result": [
                true,
                "Correct.",
                "myreverse =\n    (foldl (flip (:)) [])",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat []     = []\nmyconcat (x:xs) = x ++ (myconcat xs)",
        "output": {
            "result": [
                true,
                "Correct.",
                "myconcat [] =\n    []\nmyconcat (x : xs) =\n    x ++ (myconcat xs)",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength []    = 0\nmylength (x:s) = 1+mylength s",
        "output": {
            "result": [
                true,
                "Correct.",
                "mylength [] =\n    0\nmylength (x : s) =\n    1 + mylength s",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse [] = []\nmyreverse (x:s) = myreverse s ++ [x]",
        "output": {
            "result": [
                true,
                "Correct.",
                "myreverse [] =\n    []\nmyreverse (x : s) =\n    myreverse s ++ [x]",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/dropevery",
        "input": "dropevery [] n = []\ndropevery xs n = take (n-1) xs ++ dropevery (drop n xs) n",
        "output": {
            "result": [
                true,
                "Correct.",
                "dropevery [] n =\n    []\ndropevery xs n =\n    take (n - 1) xs ++ dropevery (drop n xs) n",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "dropevery :: [a] -> Int -> [a]"
    },
    {
        "exerciseid": "haskell/list/dupli",
        "input": "dupli = foldr (\\x y -> x:x:y) []",
        "output": {
            "result": [
                true,
                "Correct.",
                "dupli =\n    foldr (\\ x y -> x : x : y) []",
                true
            ],
            "error": null
        },
        "category": "Complete",
        "typesig": "dupli :: [a] -> [a]"
    }
]