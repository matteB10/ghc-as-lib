[
    {
        "exerciseid": "haskell/encoding/fromBin",
        "input": "fromBin [] = 0",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "fromBin :: [Int] -> Int"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = []\ncompress (x:y:ys) = if x == y then x:rest else x:y:rest where\n   rest = compress ys",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:[]) = x\nmylast (x:xs) = mylast xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "\nmylast (x:xs) = mylast xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:[]) = x\nmylast (x:xs) = mylast (xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:xs) = mylast xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:xs) | length xs == 0 = x\n              | otherwise = mylast xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:xs) = x",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:xs)= last xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat [a] n = [a] !! (n - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x : []) = x\nmylast (x : xs) = mylast xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:xs) = last xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength [x] = 1\nmylength (x:xs) = 1 + mylength xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat [x] 1 = x\nelementat (x:xs) n = elementat xs (n - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) 1 = x\nelementat [a] n = [a] !! (n - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat [x] 1 = x\nelementat [a] n = [a] !! (n - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) n | n == 0 && not (null xs) = x\n                   | otherwise = elementat xs (n-1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "elementat l n =\n    l !! (n - 1)",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse (x:xs) = myreverse xs ++ [x]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) n | n == 0 && not (null (x:xs)) = x\n                   | otherwise                   = elementat xs (n-1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast [a] = \n  head [a]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [] = []\nmyconcat [(x:xs)] = x : myconcat [xs]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [[]] = []",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress (x:y:ys) | x == y = x : compress ys\n                  | x /= y = x : y : compress ys\ncompress (x:xs) = x : xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [[]] = []\nmyconcat [(x:xs)] = x : myconcat [xs]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [[]] = [] \nmyconcat ([x]:[xs]) = myconcat  _",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse (x : []) = [x]\nmyreverse (x : xs) = myreverse xs ++ [x]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [x] = [[x]]\npack (x:xs) =  _",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = []\ncompress (x: y : xs) = if x == y\n                        then compress (y:xs)\n                        else x: compress(xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = [[]]",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "pack ? =\n    ?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = [] \ncompress (x:y:xs) | x == y = compress(x:xs)\n                  | otherwise = (x:y: compress xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "compress [] =\n    []",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myreverse",
        "input": "myreverse (x:xs) = end (x:xs) : front (x:xs)\n                     where end [x] = x\n                           end (x:xs) = end xs \n                           front [x,y] = [x]\n                           front (x:xs) = x : front xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myreverse :: [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [x] = [x]\ncompress (x:xs) |x == head xs = compress xs\n                |otherwise = x : compress xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress [] = []\ncompress (x: y : xs) = if x == y\n                        then x :  compress(y:xs)\n                        else x: compress(xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) n\n   |n == 0 = x\n   |otherwise = elementat xs (n - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength (x:xs)\n   |null xs = 0\n   |otherwise = 1 + mylength xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/mylength",
        "input": "mylength (x:xs)\n   |null xs = 1\n   |otherwise = 1 + mylength xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylength :: [a] -> Int"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = []\npack [x] = [[x]]\npack (x:y:xs) | x == y =  _",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/pack",
        "input": "pack [] = [[]]\npack [x] = [[x]]\npack (x:y:xs) | x == y =  _",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "pack :: Eq a => [a] -> [[a]]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress (x:y:xs) | x == y = compress (y:xs)\n                  | True = compress (y:xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "compress =\n    ?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/compress",
        "input": "compress (x:y:xs) | x == y = compress (y:xs)\n                  | True = x : compress (y:xs)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "compress =\n    ?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "compress :: Eq a => [a] -> [a]"
    },
    {
        "exerciseid": "haskell/list/myconcat",
        "input": "myconcat [x] = x\nmyconcat (x:xs) = x ++ myconcat xs",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "myconcat :: [[a]] -> [a]"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast [x] = x\nmylast (x:xs)=x",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/mylast",
        "input": "mylast (x:[]) = x\nmylast (x:xs)= x",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "mylast :: [a] -> a"
    },
    {
        "exerciseid": "haskell/list/elementat",
        "input": "elementat (x:xs) 0 = x\nelementat (x:xs) y = elementat xs (y - 1)",
        "output": {
            "result": [
                false,
                "Your program is not defined on all possible input. We cannot give a definitive diagnosis, please continue implementing the solution.",
                "?",
                false
            ],
            "error": null
        },
        "category": "Missing",
        "typesig": "elementat :: [a] -> Int -> a"
    }
]